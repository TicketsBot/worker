// Code generated by /tools/cmd/generatecmdcaller.go; DO NOT EDIT.
//go:generate go run ../tools/cmd/generatecmdcaller.go

package event

import (
    "fmt"
    "github.com/TicketsBot/worker/bot/command"
    cmdcontext "github.com/TicketsBot/worker/bot/command/context"
    {{- range .imports}}
    "{{.}}"
    {{- end}}
    "github.com/TicketsBot/worker/bot/command/registry"
    "github.com/pkg/errors"
    "github.com/rxdn/gdl/objects/interaction"
    "strconv"
)

var ErrArgumentNotFound = errors.New("argument not found")

func callCommand(
    cmd registry.Command,
    ctx *cmdcontext.SlashCommandContext,
    options []interaction.ApplicationCommandInteractionDataOption,
) error {
    switch v := cmd.(type) {
    {{range .executors}}
    case {{.ImportName}}:
        {{- range $i, $arg := .Arguments}}
        {{- if $arg.Required}}
        var arg{{$i}} {{index $.typeMap $arg.Type}}
        {{- else}}
        var arg{{$i}} *{{index $.typeMap $arg.Type}}
        {{- end}}

        opt{{$i}}, ok{{$i}} := findOption(cmd.Properties().Arguments[{{$i}}], options)
        if !ok{{$i}} {
            {{- if $arg.Required}}
            return ErrArgumentNotFound
            {{- else}}
            arg{{$i}} = nil
            {{- end}}
        } else {
            {{- if eq $arg.Type 3 }} {{/* string */}}
            argValue, ok := opt{{$i}}.Value.(string)
            if !ok {
                return fmt.Errorf("option %s was not a string", opt{{$i}}.Name)
            }

            {{- if $arg.Required}}
            arg{{$i}} = argValue
            {{- else}}
            arg{{$i}} = &argValue
            {{- end}}

            {{- else if eq $arg.Type 4 }} {{/* integer */}}
            argValue, ok := opt{{$i}}.Value.(float64)
            if !ok {
                return fmt.Errorf("option %s was not a float64", opt{{$i}}.Name)
            }

            {{- if $arg.Required}}
            arg{{$i}} = int(argValue)
            {{- else}}
            tmp := int(argValue)
            arg{{$i}} = &tmp
            {{- end}}

            {{- else if eq $arg.Type 5 }} {{/* boolean */}}
            argValue, ok := opt{{$i}}.Value.(bool)
            if !ok {
                return fmt.Errorf("option %s was not a bool", opt{{$i}}.Name)
            }

            {{- if $arg.Required}}
            arg{{$i}} = argValue
            {{- else}}
            arg{{$i}} = &argValue
            {{- end}}

            {{/* user, channel, role, mentionable */}}
            {{- else if or (eq $arg.Type 6) (eq $arg.Type 7) (eq $arg.Type 8) (eq $arg.Type 9) }}
            raw, ok := opt{{$i}}.Value.(string)
            if !ok {
                return fmt.Errorf("option %s was not a snowflake", opt{{$i}}.Name)
            }

            argValue, err := strconv.ParseUint(raw, 10, 64)
            if err != nil {
                return fmt.Errorf("option %s was not a valid snowflake", opt{{$i}}.Name)
            }

            {{- if $arg.Required}}
            arg{{$i}} = argValue
            {{- else}}
            arg{{$i}} = &argValue
            {{- end}}

            {{- else if eq $arg.Type 10 }} {{/* number */}}
            argValue, ok := opt{{$i}}.Value.(float64)
            if !ok {
                return fmt.Errorf("option %s was not a float64", opt{{$i}}.Name)
            }

            {{- if $arg.Required}}
            arg{{$i}} = argValue
            {{- else}}
            arg{{$i}} = &argValue
            {{- end}}

            {{- else }}
                {{panic "unsupported command option type"}}

            {{- end}}
        }
        {{- end}}

        v.Execute(ctx{{range $i, $arg := .Arguments}}, arg{{$i}}{{end}})
    {{- end}}

    {{/* special case */}}
    case tags.TagAliasCommand:
        v.Execute(ctx)

    default:
        return fmt.Errorf("unknown command %s", cmd.Properties().Name)
    }

    return nil
}

func findOption(
    arg command.Argument,
    options []interaction.ApplicationCommandInteractionDataOption,
) (interaction.ApplicationCommandInteractionDataOption, bool) {
    for _, option := range options {
        if option.Name == arg.Name {
            return option, true
        }
    }

    return interaction.ApplicationCommandInteractionDataOption{}, false
}
